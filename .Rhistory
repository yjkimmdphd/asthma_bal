stuff,
index = c("representative","description"),
vSize = "log_value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
stuff$value <- as.numeric( as.character(stuff$value) )%>%log;
stuff$frequency <- as.numeric( as.character(stuff$frequency) );
stuff$uniqueness <- as.numeric( as.character(stuff$uniqueness) );
stuff$dispensability <- as.numeric( as.character(stuff$dispensability) );
# by default, outputs to a PDF file
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_pos_perc.pdf", width=16, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
stuff$value
stuff$value <- log(as.numeric( as.character(stuff$value) ));
stuff$frequency <- as.numeric( as.character(stuff$frequency) );
stuff$uniqueness <- as.numeric( as.character(stuff$uniqueness) );
stuff$dispensability <- as.numeric( as.character(stuff$dispensability) );
# by default, outputs to a PDF file
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_pos_perc.pdf", width=16, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
stuff$value
stuff$value <- log(as.numeric( as.character(stuff$value) )+0.01);
stuff$frequency <- as.numeric( as.character(stuff$frequency) );
stuff$uniqueness <- as.numeric( as.character(stuff$uniqueness) );
stuff$dispensability <- as.numeric( as.character(stuff$dispensability) );
# by default, outputs to a PDF file
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_pos_perc.pdf", width=16, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
stuff$value
stuff <- data.frame(revigo.data);
names(stuff) <- revigo.names;
stuff$value <- log(as.numeric( as.character(stuff$value) )+0.01);
stuff$frequency <- as.numeric( as.character(stuff$frequency) );
stuff$uniqueness <- as.numeric( as.character(stuff$uniqueness) );
stuff$dispensability <- as.numeric( as.character(stuff$dispensability) );
stuff$value
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_pos_perc.pdf", width=16, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
stuff$value
stuff <- data.frame(revigo.data);
names(stuff) <- revigo.names;
log(as.numeric( as.character(stuff$value) )+0.01)
stuff$value
as.numeric( as.character(stuff$value)
)
stuff$value <- log(as.numeric( as.character(stuff$value) )+1);
stuff$frequency <- as.numeric( as.character(stuff$frequency) );
stuff$uniqueness <- as.numeric( as.character(stuff$uniqueness) );
stuff$dispensability <- as.numeric( as.character(stuff$dispensability) );
# by default, outputs to a PDF file
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_pos_perc.pdf", width=16, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_pos_perc.pdf", width=16, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
dev.off()
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
revigo.names <- c("term_ID","description","frequency","value","uniqueness","dispensability","representative");
revigo.data <- rbind(c("GO:0003341","cilium movement",0.9515229998310906,10.191114132640188,0.683915482109657,0.00519511,"cilium movement"),
c("GO:0007018","microtubule-based movement",2.1901919936940484,3.9706162223147903,0.704530660392689,0.68842059,"cilium movement"),
c("GO:0006954","inflammatory response",3.1135634254827993,0.8760629355058556,0.9830383673916627,-0,"inflammatory response"),
c("GO:0007166","cell surface receptor signaling pathway",11.727943246438826,0.716803114031512,0.9533981351135186,0.1504454,"inflammatory response"),
c("GO:0007155","cell adhesion",5.360058555261528,1.4590709245654105,0.9929719930727134,0.00649384,"cell adhesion"),
c("GO:0007156","homophilic cell adhesion via plasma membrane adhesion molecules",0.9402623726141547,4.913640169325252,0.9942224017300052,0.00518796,"homophilic cell adhesion via plasma membrane adhesion molecules"),
c("GO:0007368","determination of left/right symmetry",0.715049828275435,5.230622673923862,0.848436422923372,-0,"determination of left/right symmetry"),
c("GO:0001775","cell activation",4.031304543663082,1.749092227185601,0.9416623920329603,0.1511869,"determination of left/right symmetry"),
c("GO:0001782","B cell homeostasis",0.16890940825403974,0.7630546103969275,0.9169450719780069,0.10883154,"determination of left/right symmetry"),
c("GO:0007283","spermatogenesis",3.400709419514667,0.4337626605532327,0.9085686413627738,0.19068666,"determination of left/right symmetry"),
c("GO:0007399","nervous system development",12.358538370587242,1.6404282277341427,0.9027504967553278,0.33701693,"determination of left/right symmetry"),
c("GO:0030216","keratinocyte differentiation",0.8051348460109229,0.6404411716911126,0.9328799507099006,0.18004148,"determination of left/right symmetry"),
c("GO:0018095","protein polyglutamylation",0.0731940769100839,0.6547353018251958,0.9865437898866648,-0,"protein polyglutamylation"),
c("GO:0035970","peptidyl-threonine dephosphorylation",0.10134564495242385,0.43174512506227813,0.9808365957931059,0.23840675,"protein polyglutamylation"),
c("GO:0032731","positive regulation of interleukin-1 beta production",0.3434491301165475,2.6621485532414306,0.896592040716028,-0,"positive regulation of interleukin-1 beta production"),
c("GO:0002224","toll-like receptor signaling pathway",0.24210348516412367,1.4921931308155818,0.8757903181302508,0.33457752,"positive regulation of interleukin-1 beta production"),
c("GO:0006955","immune response",9.076065536850402,0.3110211026368808,0.9268286368879436,0.42974798,"positive regulation of interleukin-1 beta production"),
c("GO:0032760","positive regulation of tumor necrosis factor production",0.5686616744552672,1.749092227185601,0.893158656799257,0.64678495,"positive regulation of interleukin-1 beta production"),
c("GO:0043280","positive regulation of cysteine-type endopeptidase activity involved in apoptotic process",0.681267946624627,0.4750264918197695,0.9025415065505383,0.52253278,"positive regulation of interleukin-1 beta production"),
c("GO:0043406","positive regulation of MAP kinase activity",0.664377005799223,1.5281935003660572,0.883487961217612,0.24567197,"positive regulation of interleukin-1 beta production"),
c("GO:0051092","positive regulation of NF-kappaB transcription factor activity",0.8952198637464107,0.6404411716911126,0.922113872037095,0.46496883,"positive regulation of interleukin-1 beta production"),
c("GO:0051770","positive regulation of nitric-oxide synthase biosynthetic process",0.10134564495242385,0.43174512506227813,0.9335155236758914,0.20891751,"positive regulation of interleukin-1 beta production"),
c("GO:1900017","positive regulation of cytokine production involved in inflammatory response",0.1463881538201678,0.5037124895992726,0.9021609386044755,0.57484535,"positive regulation of interleukin-1 beta production"),
c("GO:0034440","lipid oxidation",0.49546759754518327,0.32191826446161936,0.9877511739266365,0.0653834,"lipid oxidation"),
c("GO:0060271","cilium assembly",1.8523731771859693,11.60906489289662,0.7665462750161023,0,"cilium assembly"),
c("GO:0030030","cell projection organization",6.548054726648274,0.8551008624548749,0.9285799131946856,0.2409233,"cilium assembly"),
c("GO:0035720","intraciliary anterograde transport",0.09571533134395585,0.3898012686331238,0.6136081764120076,0.69666532,"cilium assembly"),
c("GO:0070269","pyroptosis",0.16890940825403974,1.1404762227349963,0.9950879304954866,0.00432926,"pyroptosis"),
c("GO:1904491","protein localization to ciliary transition zone",0.045042508867743934,1.3043900767241563,0.9242118131303051,0.00383993,"protein localization to ciliary transition zone"),
c("GO:0051649","establishment of localization in cell",10.027588536681494,2.6798188054962693,0.8971723197689635,0.32176205,"protein localization to ciliary transition zone"),
c("GO:0061512","protein localization to cilium",0.3378188165080795,0.9477097394394682,0.913944754525593,0.45986453,"protein localization to ciliary transition zone"));
stuff <- data.frame(revigo.data);
names(stuff) <- revigo.names;
stuff$value <- as.numeric( as.character(stuff$value) );
stuff$frequency <- as.numeric( as.character(stuff$frequency) );
stuff$uniqueness <- as.numeric( as.character(stuff$uniqueness) );
stuff$dispensability <- as.numeric( as.character(stuff$dispensability) );
# by default, outputs to a PDF file
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_pos_ct_perc_Overlap.pdf", width=16, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
dev.off()
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
stuff <- data.frame(revigo.data);
names(stuff) <- revigo.names;
stuff$value <- log(as.numeric( as.character(stuff$value) )+1);
stuff$frequency <- as.numeric( as.character(stuff$frequency) );
stuff$uniqueness <- as.numeric( as.character(stuff$uniqueness) );
stuff$dispensability <- as.numeric( as.character(stuff$dispensability) );
# by default, outputs to a PDF file
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_pos_ct_perc_Overlap.pdf", width=16, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
dev.off()
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
revigo.names <- c("term_ID","description","frequency","value","uniqueness","dispensability","representative");
revigo.data <- rbind(c("GO:0002181","cytoplasmic translation",0.692528573841563,5.017728766960432,1,0,"cytoplasmic translation"));
stuff <- data.frame(revigo.data);
names(stuff) <- revigo.names;
stuff$value <- as.numeric( as.character(stuff$value) );
stuff$frequency <- as.numeric( as.character(stuff$frequency) );
stuff$uniqueness <- as.numeric( as.character(stuff$uniqueness) );
stuff$dispensability <- as.numeric( as.character(stuff$dispensability) );
# by default, outputs to a PDF file
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_all_perc.pdf", width=16, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
dev.off()
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
pdf( file="./reports/DEG_venn/GO_nasal_ser_eos_all_perc.pdf", width=9, height=9 ) # width and height are in inches
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
dev.off()
# check the tmPlot command documentation for all possible parameters - there are a lot more
treemap(
stuff,
index = c("representative","description"),
vSize = "value",
type = "categorical",
vColor = "representative",
title = "Revigo TreeMap",
inflate.labels = FALSE,      # set this to TRUE for space-filling group labels - good for posters
lowerbound.cex.labels = 0,   # try to draw as many labels as possible (still, some small squares may not get a label)
bg.labels = "#CCCCCCAA",   # define background color of group labels
# "#CCCCCC00" is fully transparent, "#CCCCCCAA" is semi-transparent grey, NA is opaque
position.legend = "none"
)
library(limma)
library(edgeR)
library(dplyr)
library(DESeq2)
######################
## load readcount data
######################
# load count data from seq batch 1-4
counts<-file.path("./resources/working_data/copy_of_batch1234_readcount_matrix_allsamples.afterQC.txt") # original RNAseqs count data table is in the MS_asthma folder
counts<-if(file.exists(counts)){read.delim(counts)}
counts.ID<-colnames(counts)
################################
## load phenotype and batch data
################################
# asthma biomarker phenotype file saved in  'phenotype'
phenotype<-file.path("./resources/processed_data/asthma-phenotype-Rnaseq-2023-12-01.csv")
phenotype<-if(file.exists(phenotype)){read.csv(phenotype, row.names = NULL)}
numeric_id<-phenotype$subjID
phenotype$subjID<-sprintf("%03d",numeric_id) # adds padded zeros in front of the subject ID numbers
# make vectors of variables for later use as an input for function 'run_deseq2_DEG_analysis'
source.cell.log<-c("BAL_Eos_ct_log",
"BAL_Eos_perc_log",
"BAL_neut_ct_log10",
"BAL_neut_perc_log",
"BAL_WBC_log",
"serum_Eos_log10",
"serum_Eos_perc_log",
"serum_Neut_log10",
"serum_Neut_perc_log",
"serum_WBC_log10")
source.cell<-c("BAL_Eos_ct",
"BAL_Eos_perc",
"BAL_neut_ct",
"BAL_neut_perc",
"BAL_WBC",
"serum_Eos",
"serum_Eos_perc",
"serum_Neut",
"serum_neut_perc",
"serum_WBC")
deg.design<-paste("~",source.cell.log,"+ Batch")
#######################################################################
## find subject assignment ID with nasal and bronchial cell RNAseq data
#######################################################################
nID<-paste0("N",phenotype$subjID) # N*** indicates bronchial sample ID, sequence data is not available for all as of 2023-10-04
bID<-paste0("B",phenotype$subjID) # B*** indicates bronchial sample ID, sequence data is not available for all as of 2023-10-04
nexist<-counts.ID%in%nID # find which subjects s/p nasal and had bronchial sample RNAseq completed. Nasal samples in batch 1-4 only sequenced to subjID 337
bexist<-counts.ID%in%bID # find which subjects s/p BAL and had bronchial sample RNAseq completed
nsample<-counts.ID[nexist] # nasal sample ID in the readcount matrix (batch 1-4) that has BAL phenotype data
bsample<-counts.ID[bexist] # bronchial sample ID in the readcount matrix (batch 1-4) that has BAL phenotype data
nphen<-phenotype[phenotype$subjID%in%substring(nsample,2),] # phenotype table with nsample
bphen<-phenotype[phenotype$subjID%in%substring(bsample,2),] # phenotype table with bsample
nphen<-mutate(nphen, SampleID=nsample)%>%relocate(SampleID, .before=1) # include sample ID for nasal RNAseq samples
bphen<-mutate(bphen, SampleID=bsample)%>%relocate(SampleID, .before=1) # include sample ID for bronchial RNAseq samples
# left join batch info table with nasal/bronchial phenotype table
## get batch information
batch<-file.path("./resources/processed_data/asthma_nasal_bronchial_batch1234_info.txt")
batch.info<-if(file.exists(batch)){read.delim(batch)}
## define function join_phenotype_batch_info.
join_phenotype_batch_info<-function(p,b){
#p is phenotype table. b is batch info table. Factorize the batch info.
table<-left_join(p,b, by="SampleID")
table$Batch<-factor(table$Batch, levels=unique(table$Batch))
return(table)
}
nphen<-join_phenotype_batch_info(nphen,batch.info)
bphen<-join_phenotype_batch_info(bphen,batch.info)
# scale the cell count information
# Mike Love: I'd recommend however to center and scale the numeric covariates for model fitting improvement.
# scale the columns named with source.cell.log
nphen<-mutate_at(nphen,vars(all_of(source.cell.log)),scale) # scales and mutates all log-transformed cell counts
bphen<-mutate_at(bphen,vars(all_of(source.cell.log)),scale) # scales and mutates all log-transformed cell counts
# make a list in which each element is a numeric vector of row numbers corresponding to rows of interests in phenotype data matching the following condition:
## nasal RNAseq samples with cell counts at least 0
source.cell.all<-sapply(nphen[,source.cell],function(p){a<-p; b<-which(a>=0); return(b)})
# define function 'subset_phenotype'
subset_phenotype<-function(phenotype_data, source_cell_list, source_cell, sample_id, v1, v2){## make function that subsets the phenotype data referencing the rownames saved in the list data made above using the following function
## the inputs are the phenotype_data to subset, the list file (source_cell_df), source (BAL/serum) and cell type (eos,neut,wbc) to subset with, sample ID, and independent variables that will be used for downstream DEG analysis (v1, v2)
l<-source_cell_list
sc<-source_cell
p<-phenotype_data #phenotype data for nasal/bronchial RNAseq samples
rn<-as.numeric(unlist(l[sc]))
sp<-p[rn,c(sample_id,v1,v2)]
return(sp)
}
##df with bal eos>0
bal.all.e.c<-subset_phenotype(nphen,source.cell.all,"BAL_Eos_ct","SampleID","BAL_Eos_ct_log", "Batch")
bal.all.e.p<-subset_phenotype(nphen,source.cell.all,"BAL_Eos_ct","SampleID","BAL_Eos_perc_log", "Batch")
##df with bal neut>0
bal.all.n.c<-subset_phenotype(nphen,source.cell.all,"BAL_neut_ct","SampleID","BAL_neut_ct_log10","Batch")
bal.all.n.p<-subset_phenotype(nphen,source.cell.all,"BAL_neut_ct","SampleID","BAL_neut_perc_log","Batch")
##df with bal WBC>0
bal.all.w.c<-subset_phenotype(nphen,source.cell.all,"BAL_WBC","SampleID","BAL_WBC_log","Batch")
##df with serum_Eos>0
ser.all.e.c<-subset_phenotype(nphen,source.cell.all,"serum_Eos","SampleID","serum_Eos_log10", "Batch")
ser.all.e.p<-subset_phenotype(nphen,source.cell.all,"serum_Eos","SampleID","serum_Eos_perc_log","Batch")
##df with serum_Neut>0
ser.all.n.c<-subset_phenotype(nphen,source.cell.all,"serum_Neut","SampleID","serum_Neut_log10","Batch")
ser.all.n.p<-subset_phenotype(nphen,source.cell.all,"serum_Neut","SampleID","serum_Neut_perc_log","Batch")
##df with serum WBC>0
ser.all.w.c<-subset_phenotype(nphen,source.cell.all,"serum_WBC","SampleID","serum_WBC_log10","Batch")
## make dictionary table of df names and corresponding source cell counts
df.all.cell<-data.frame(source_cell = paste(source.cell,">=0"),
df_name=c("bal.all.e.c",
"bal.all.e.p",
"bal.all.n.c",
"bal.all.n.p",
"bal.all.w.c",
"ser.all.e.c",
"ser.all.e.p",
"ser.all.n.c",
"ser.all.n.p",
"ser.all.w.c"),
row.names = NULL)
## check if any df has NA
sapply(df.all.cell$df_name,function(df){a<-get(df);is.na(a[,2])})%>%lapply(sum)
## check # of samples for each bronchial RNAseq sample phenotype
n_sample_pos<-unlist(sapply(df.all.cell$df_name,function(df){a<-get(df);nrow(a)})%>%lapply(sum))
df.all.cell<-cbind(df.all.cell,n_sample_pos)
###########################################
## filtering counts table to remove low expressed genes
###########################################
# select just the nasal RNAseq counts
id<-counts.ID%in%nID
cols<-colnames(counts)[id]
ncounts<-counts[,cols] # First column is actually gene name
genes<-counts$SampleID
rownames(ncounts)<-genes
# Filter bcounts (readcount table for bronchial sample
## filter method 1:
### Remove genes with ≤ 2 counts per million in >10% of samples (>4 samples) were removed to reduce noise on low counts and low abundance genes (PMID: 37730635)
filter_low_expressed_genes_method1<-function(readcounts, cutoff, n_sample){
x<-readcounts
cpm0 <-cpm(readcounts)
drop.genes<-which(rowSums(cpm0<=cutoff)>n_sample)
x<-x[-drop.genes,]
print(paste("# of dropped genes:",length(drop.genes)))
return(x)
}
c1<-filter_low_expressed_genes_method1(ncounts, 2, 4)
## filter method 2: use TMM normalized lcpm as a cutoff point
### x will be the TMM normalized count
filter_low_expressed_genes_method2<-function(readcounts, n_sample){
x<-readcounts
L<-mean(colSums(x))*1e-6 # mean library size
M<-median(colSums(x))*1e-6 # median library size
lcpm.cutoff <- log2(10/M + 2/L) # lcpm cutoff for filtering genes with very low counts
### normalize counts with TMM
norm.factor<-calcNormFactors(x, method = "TMM")
sample.size<-length(colnames(x))
for(i in 1:sample.size){
x[,i]<-x[,i]/norm.factor[i]
}
### calculate lcpm based on TMM normalized counts
lcpm.x<-cpm(x,log=TRUE)
drop.genes<-which(rowSums(lcpm.x<lcpm.cutoff)>n_sample) # which genes have normalized lcpm less than the cutoff in >10% of the samples
x<-x[-drop.genes,] # readcounts retained
print(paste("# of dropped genes:",length(drop.genes))) # number of dropped genes
return(x)
}
c2<-filter_low_expressed_genes_method2(ncounts,4)
M
L
x<-ncounts
L<-mean(colSums(x))*1e-6 # mean library size
M<-median(colSums(x))*1e-6 # median library size
lcpm.cutoff <- log2(10/M + 2/L)
L
M
